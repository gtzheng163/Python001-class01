学习笔记
fork（）
Unix/Linx操作系统提供了一个fork（）系统调用，它非常特殊，不同于普通的函数（调用一次，返回一次），fork（）调用一次，返回两次。
这是因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后分别在父进程和子进程中返回。
在子进程中永远返回0，而在父进程中返回子进程的ID。这样做是因为一个父进程可以fork出很多子进程，
所以父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。
multiprocessing模块
multiprocessing模块就是跨平台版本的多进程模块。在multiprocessing模块中提供了一个Process类来代表一个进程对象。
用multiprocessing创建子进程时，Process类代表一个进程，只需传入子进程需执行的函数和参数，用start方法启动子进程，
join（）方法可以等待子进程结束后再往下运行（通常用于进程间的同步）。
进程池Pool，可以批量创建进程。
进程的通信
Process之间肯定是需要通信的，Python的multiprocessing模块包装了底层的机制，提供了Queue（队列）、Pipes（管道）等多种方式来交换数据。
多线程
线程是操作系统直接支持的执行单元，Python的标准库提供了两个模块：_thread和threading,前者是低级模块，后者是高级模块，后者分装了前者。
启动一个线程就是把一个函数传入并创建Thread实例，然后调用start（）执行。
lock
多线程有风险，因为在多线程所有变量被所有线程共享，此时可能会出现多个线程同时改变一个变量，导致出现错误。为了避免这个错误的出现，我们应该加锁lock。
Tips:锁的坏处就是阻止了多线程的并发执行，效率大大地下降了。当不同的线程持有不同的锁，并试图获取对方的锁时，可能会造成死锁。
Python中使用线程的局部变量使用ThreadLocal，threaLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求用户信息身份等。
Tip:一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。

进程和线程
多进程模式最大的优点就是稳定性高，这是因为一个子进程崩溃了，不会影响主进程和其他子进程；
但是多进程的缺点就是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，但是在Windows下创建进程的开销巨大。
操作系统能同时运行的进程也是有限的，在CPU和内存的限制下，如果有几千个进程同时运行，那么操作系统连调度都会成问题。
多线程模式通常比多进程模式快一点，但也快不到哪去。而且，多线程模式致命的缺点就是因为任何一个线程crash了都可能造成整个进程crash，因为所有线程共享进程的内存。

管道的通信原理：
在内存中开辟管道空间，生成管道操作对象，多个进程使用"同一个"管道对象进行操作即可实现通信。
消息队列的通信原理：
在内存中建立队列(先进先出)数据结构模型。多个进程都可以向队列存入内容，取出内容的顺序和存入顺序保持一致。
共享内存的通信原理：
在内存空开辟一块空间，对多个进程可见，进程可以写入输入，但是每次写入的内容会覆盖之前的内容。

本周学习内容是对进程和线程的一个学习，结合老师的视频的例子对进程和线程有个大概的了解，需要多练练才能进一步体会到进程和线程的联系与区别。